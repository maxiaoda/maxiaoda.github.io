<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 马小达的博客</title>
    <link>https://maxiaoda.github.io/posts/</link>
    <description>Recent content in Posts on 马小达的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 27 Feb 2020 12:35:39 +0800</lastBuildDate>
    
	<atom:link href="https://maxiaoda.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于Collection的博客</title>
      <link>https://maxiaoda.github.io/posts/%E5%85%B3%E4%BA%8Ecollection%E7%9A%84%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Thu, 27 Feb 2020 12:35:39 +0800</pubDate>
      
      <guid>https://maxiaoda.github.io/posts/%E5%85%B3%E4%BA%8Ecollection%E7%9A%84%E5%8D%9A%E5%AE%A2/</guid>
      <description>Collection体系的常用类及其背后的数据结构 一、Collection的常用类   List
可以保存重复元素，拥有下标，存储有序，可以存储多个null元素。常用的类有：
   ArrayList LinkedList   Set
不能保存重复元素，没有下标，可以存储null但只能有一个，并且不保证存取顺序。常用的类有：
   HashSet（无序） LinkedHashSet（有序） TreeSet（排序）  Collection体系如下图： 二、Collection背后的数据结构  ArrayList与LinedList   Arraylist：底层使用的是 Object 数组。 LinkedList：底层使用的是 双向链表 数据结构。   HashSet、LinkedHashSet与TreeSet   HashSet: 底层采用 HashMap 来保存元素，HashMap 使用的是拉链法，也叫作【链地址法】。 LinkedHashSet：底层是链表+哈希表，链表保证数据存储有序，链表用来记录存储顺序；哈希表保证数据唯一，存储真正的数据 TreeSet：红黑树(自平衡二叉查找树)。  </description>
    </item>
    
    <item>
      <title>我认为的Maven与Java的包管理</title>
      <link>https://maxiaoda.github.io/posts/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84maven%E4%B8%8Ejava%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 24 Feb 2020 17:35:22 +0800</pubDate>
      
      <guid>https://maxiaoda.github.io/posts/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84maven%E4%B8%8Ejava%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>我认为的Maven与Java的包管理 对Java和Maven的简单理解 学习了Java的包管理与Maven的包管理后，我认为最直观的对它们的理解是，Java相当于一个社会，而Maven相当于这个社会中的其中一个管理者。假设要找一个包，Java会挨个搜索，在信息不全面的情况下找到叫同样名字的包就认为这个就是了。而Maven作为管理者，会定位到家庭住址，将这个包找出来。
Java的包管理 Java的管理机制很简单，将class path告诉jvm就好，而jvm更简单，给什么就编译什么。找不到方法，就在给jvm的class path中找错误。最重要的一个问题是累，不管是用到什么依赖，从开始的下载到之后的用，无论干什么都是手动控制，是非常非常的耗时耗力。
Maven的包管理 划时代的包管理工具，一个有效解决依赖的工具，Maven解决了Java的包依赖和class path问题。将所有的包集中在一个仓库中。
只需要仓库中找到&amp;lt;groupId&amp;gt;``&amp;lt;artifactId&amp;gt;``&amp;lt;version&amp;gt;的代码块
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;XXXX&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;XXXX&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;XXX.XXX.XXX&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 告诉了Maven地址、街道、门牌号，剩下的Maven自己开始寻找这个包了。对比java，感受到了Maven的轻松。
那么依赖冲突怎么解决的呢，依赖路径最短优先原则：A-&amp;gt;B-&amp;gt;C和A-&amp;gt;C那么后者路径最短，优先选择路径最短的，即选择A-&amp;gt;C。
pom.xml文件是Maven管理这记录的名单，查的时候就看这个文件。pom.xml采用顺序优先原则，谁先被提到就用哪个依赖。  总结 最后，为什么Maven管理的比Java好呢？ 因为在Maven中有很强的约束，将这个包仓库管理的井井有条。</description>
    </item>
    
    <item>
      <title>搭建个人博客</title>
      <link>https://maxiaoda.github.io/posts/%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 22 Feb 2020 11:01:50 +0800</pubDate>
      
      <guid>https://maxiaoda.github.io/posts/%E5%8D%9A%E5%AE%A2/</guid>
      <description>如何用hugo搭建个人博客 本人搭建环境：
 windows10 操作系统； 安装Git，version-2.25.0； 安装hugo，version-v0.65.2；   搭建步骤如下：
  安装Hugo和添加环境变量：
在Hugo的官方Github中，找到 Releases 下载对应的操作系统版本。将安装目录添加至windows系统环境变量中。   使用命令新建一个网站（使用命令时会在当前目录生效）。
   hugo new site SiteName 进入SiteName目录cd SiteName输入以下命令，添加一个主题。  git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 将主题添加至config.toml中。  echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml 添加一篇名为my-first-post的博客。  hugo new posts/my-first-post.md 在my-first-post文件头部中的draft改为flase即可发布博客。  title: &amp;quot;My First Post&amp;quot; date: 2019-03-26T08:47:11+01:00 draft: true 启动Hugo server  hugo server -D  成功后访问http://localhost:1313/
 配置config.toml，baseURL设为新域名，languageCode的中文为zh-Hans，title为自己的博客名称。  baseURL = &amp;quot;https://example.</description>
    </item>
    
  </channel>
</rss>